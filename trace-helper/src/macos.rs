use mach2::exception_types::*;
use mach2::kern_return::kern_return_t;
use mach2::mach_types::task_t;
use mach2::message::mach_msg_type_number_t;
use mach2::port::mach_port_t;
use mach2::thread_status::{thread_state_flavor_t, THREAD_STATE_NONE};
use mach2::traps::mach_task_self;
use std::ffi::c_void;

#[repr(C)]
pub struct Interpose {
    pub replacement: *const c_void,
    pub target: *const c_void,
}

unsafe impl Send for Interpose {}
unsafe impl Sync for Interpose {}

#[macro_export]
macro_rules! dyld_interpose {
    ($name:ident, $target:expr, $replacement:expr) => {
        #[no_mangle]
        #[link_section = "__DATA,__interpose"]
        static $name: Interpose = Interpose {
            replacement: $replacement as _,
            target: $target as _,
        };
    }
}

extern "C" {
    pub fn task_get_exception_ports(
        task: task_t,
        exception_types: exception_mask_t,
        old_exception_masks: exception_mask_array_t,
        old_exception_count: *mut mach_msg_type_number_t,
        old_exception_ports: *mut mach_port_t,
        old_behaviors: exception_behavior_array_t,
        old_flavors: exception_flavor_array_t,
    ) -> kern_return_t;
    pub fn task_set_exception_ports(
        task: task_t,
        exception_types: exception_mask_t,
        exception_port: mach_port_t,
        behavior: exception_behavior_t,
        flavor: thread_state_flavor_t,
    );
}

#[no_mangle]
unsafe extern "C" fn my_fork() -> libc::pid_t {
    let child = libc::fork();

    if child == 0 {
        const EXC_TYPES_COUNT: usize = 10;
        let mut exception_masks = [0; EXC_TYPES_COUNT];
        let mut exception_ports = [0; EXC_TYPES_COUNT];
        let mut exception_behaviors = [0; EXC_TYPES_COUNT];
        let mut exception_flavors = [0; EXC_TYPES_COUNT];
        let mut exception_count = 0;

        // Query the exception ports.
        unsafe {
            task_get_exception_ports(
                mach_task_self(),
                EXC_MASK_BAD_ACCESS |
                EXC_MASK_BAD_INSTRUCTION |
                EXC_MASK_ARITHMETIC |
                EXC_MASK_EMULATION |
                EXC_MASK_SOFTWARE |
                EXC_MASK_BREAKPOINT |
                EXC_MASK_SYSCALL |
                EXC_MASK_MACH_SYSCALL,
                exception_masks.as_mut_ptr(),
                &mut exception_count,
                exception_ports.as_mut_ptr(),
                exception_behaviors.as_mut_ptr(),
                exception_flavors.as_mut_ptr(),
            );
        }

        // Look for the exception port that we inherited from the parent, if any.
        for port in exception_ports {
            if port == 0 {
                continue;
            }

            // Set the exception port again. This ensures that any exceptions generated by the
            // child task get tagged with the child task and PID. Otherwise there is a race
            // condition here, where the generated exceptions sometimes end up being tagged with
            // the parent task and PID.
            unsafe {
                task_set_exception_ports(
                    mach_task_self(),
                    EXC_MASK_BAD_ACCESS |
                    EXC_MASK_BAD_INSTRUCTION |
                    EXC_MASK_ARITHMETIC |
                    EXC_MASK_EMULATION |
                    EXC_MASK_SOFTWARE |
                    EXC_MASK_BREAKPOINT |
                    EXC_MASK_SYSCALL |
                    EXC_MASK_MACH_SYSCALL,
                    port,
                    (EXCEPTION_DEFAULT | MACH_EXCEPTION_CODES) as _,
                    THREAD_STATE_NONE,
                );
            }

            // Indicate to the tracer that we are ready to be traced.
            libc::ptrace(libc::PT_TRACE_ME, 0, std::ptr::null_mut(), 0);
            libc::ptrace(libc::PT_SIGEXC, 0, std::ptr::null_mut(), 0);

            // Suspend the task.
            libc::kill(libc::getpid(), libc::SIGSTOP);

            break;
        }
    }

    child
}

dyld_interpose!(FORK, libc::fork, my_fork);
